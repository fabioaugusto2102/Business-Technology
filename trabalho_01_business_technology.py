# -*- coding: utf-8 -*-
"""Trabalho 01 Business Technology.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oCVI1tIeXcPHAEqiS2PJIz60VXXUevHA

# üìä An√°lises para a Barba de Elite
Este notebook analisa os dados de estoque e vendas da Barba de Elite, gera previs√µes utilizando Machine Learning e calcula o Days On Hand (DOH) para um planejamento mais eficiente.

## Importa√ß√£o das bibliotecas

---



Neste bloco realiza-se a importa√ß√£o das bibliotecas que utilizaremos para a implementa√ß√£o do projeto.

---
"""

# üìå Importando as bibliotecas
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from statsmodels.tsa.arima.model import ARIMA
import plotly.io as pio
import plotly.express as px
from prophet import Prophet

"""## üì• Leitura dos arquivos CSV

---


Os arquivos precisam estar pr√© carregados no sistema do Google Colab. O bloco abaixo realiza a leitura e o carregamento dos dados desses arquivos.

---


"""

# Carregar os dados
file_estoque = 'estoque_barba_de_elite.csv'
file_vendas = 'compras_barba_de_elite.csv'

df_estoque = pd.read_csv(file_estoque)
df_vendas = pd.read_csv(file_vendas)

# Converter datas
df_vendas['Data e Hora'] = pd.to_datetime(df_vendas['Data e Hora'])
df_vendas['Data'] = df_vendas['Data e Hora'].dt.date

# Visualizar os primeiros dados
df_estoque.head(), df_vendas.head()

"""## üìä An√°lise de Vendas

---

Nesse bloco realiza-se a cria√ß√£o de um gr√°fico que nos informa o n√∫mero de vendas di√°rias. Para conseguir ver o n√∫mero exato, basta passar o mouse em cima no dia desejado.

---


"""

# Carregar os dados de vendas
df_vendas = pd.read_csv("compras_barba_de_elite.csv")

# Converter a coluna de data para formato datetime
df_vendas["Data e Hora"] = pd.to_datetime(df_vendas["Data e Hora"])
df_vendas["Data"] = df_vendas["Data e Hora"].dt.date

# Criar a s√©rie de vendas di√°rias
vendas_diarias = df_vendas.groupby("Data").size()

# Criar gr√°fico interativo de tend√™ncia de vendas di√°rias
fig = go.Figure()

fig.add_trace(go.Scatter(
    x=vendas_diarias.index,
    y=vendas_diarias.values,
    mode="lines+markers",
    name="Vendas Di√°rias",
    line=dict(color="blue")
))

# Ajustar layout do gr√°fico
fig.update_layout(
    title="Vendas Di√°rias",
    xaxis_title="Data",
    yaxis_title="Quantidade de Vendas",
    xaxis=dict(tickangle=-45),
    template="plotly_white",
    hovermode="x unified"
)

# Exibir o gr√°fico interativo
fig.show()

"""## üìä An√°lise de Vendas por M√™s

---

Nesse bloco realiza-se a cria√ß√£o de um gr√°fico que nos informa o n√∫mero de vendas mensais.

---


"""

# Criar colunas de m√™s e nome do m√™s
df_vendas["Data e Hora"] = pd.to_datetime(df_vendas["Data e Hora"])  # Garantir que a coluna seja datetime
df_vendas["M√™s"] = df_vendas["Data e Hora"].dt.month

# Criar um dicion√°rio para traduzir os meses
meses_traducao = {
    1: "Janeiro", 2: "Fevereiro", 3: "Mar√ßo", 4: "Abril", 5: "Maio", 6: "Junho",
    7: "Julho", 8: "Agosto", 9: "Setembro", 10: "Outubro", 11: "Novembro", 12: "Dezembro"
}

df_vendas["M√™s"] = df_vendas["M√™s"].map(meses_traducao)  # Traduzir os meses para portugu√™s

# Contar vendas por m√™s
vendas_por_mes = df_vendas["M√™s"].value_counts().reindex(meses_traducao.values())

# Criar gr√°fico interativo
fig = px.bar(
    x=vendas_por_mes.index,
    y=vendas_por_mes.values,
    text=vendas_por_mes.values,
    labels={"x": "M√™s", "y": "Quantidade de Vendas"},
    title="Vendas por M√™s",
    color=vendas_por_mes.values,
    color_continuous_scale="Blues"
)

# Ajustar layout
fig.update_traces(textposition="auto")
fig.update_layout(
    xaxis_title="M√™s",
    yaxis_title="Quantidade de Vendas",
    template="plotly_white"
)

# Exibir gr√°fico interativo
fig.show()

"""## üè∑Ô∏è Previs√£o de Vendas com ML


---

Nesse bloco o c√≥digo roda um modelo de ML. Essa ML faz uma previsibilidade de venda dos pr√≥ximos 6 meses.

---

"""

# Garantir que a coluna de data esteja no formato datetime
df_vendas["Data e Hora"] = pd.to_datetime(df_vendas["Data e Hora"])
df_vendas["Data"] = pd.to_datetime(df_vendas["Data e Hora"].dt.date)

# Agrupar as vendas por dia
df_vendas_diarias = df_vendas.groupby("Data").size().reset_index()
df_vendas_diarias.columns = ["ds", "y"]

# Inicializar e ajustar o modelo Prophet
modelo = Prophet(
    daily_seasonality=True,
    weekly_seasonality=True,
    yearly_seasonality=True
)
modelo.fit(df_vendas_diarias)

# Criar DataFrame futuro para 6 meses
futuro = modelo.make_future_dataframe(periods=180)
previsao = modelo.predict(futuro)

# Criar gr√°fico interativo mais limpo
fig = go.Figure()

# Linha de vendas reais
fig.add_trace(go.Scatter(
    x=df_vendas_diarias["ds"],
    y=df_vendas_diarias["y"],
    mode="lines",
    name="Vendas Reais",
    line=dict(color="#1f77b4", width=2)
))

# Linha de previs√£o
fig.add_trace(go.Scatter(
    x=previsao["ds"],
    y=previsao["yhat"],
    mode="lines",
    name="Previs√£o",
    line=dict(color="#ff7f0e", width=2, dash="dash")
))

# Layout clean
fig.update_layout(
    title="Previs√£o de Vendas para os Pr√≥ximos 6 Meses (Prophet)",
    xaxis_title="Data",
    yaxis_title="Quantidade de Vendas",
    template="plotly_white",
    hovermode="x unified",
    showlegend=True,
    legend=dict(x=0.01, y=0.99, bgcolor="rgba(255,255,255,0)", bordercolor="rgba(0,0,0,0)")
)

fig.show()

"""## üì¶ Vendas de Produto

---

Nesse bloco realiza-se a leitura de quantidades vendidas e logo em seguida entrega um gr√°fico com esses dados para uma melhor visualiza√ß√£o.

---


"""

# Contar a quantidade total vendida por item
vendas_por_produto = df_vendas["Produto"].value_counts().reset_index()
vendas_por_produto.columns = ["Produto", "Quantidade Vendida"]

# Exibir os dados
# Assuming display_dataframe_to_user is a function you want to apply:
# If it's in a specific module, import it first (e.g., from my_module import display_dataframe_to_user)
# If it's a standalone function, define it before this cell
# If it's meant to be display, simply use:
display(vendas_por_produto)

# Carregar os dados de vendas
df_vendas = pd.read_csv("compras_barba_de_elite.csv")

# Contar a quantidade total vendida por item
vendas_por_produto = df_vendas["Produto"].value_counts().reset_index()
vendas_por_produto.columns = ["Produto", "Quantidade Vendida"]

# Criar gr√°fico interativo de vendas por produto
fig = go.Figure()

fig.add_trace(go.Bar(
    x=vendas_por_produto["Produto"],
    y=vendas_por_produto["Quantidade Vendida"],
    marker=dict(color="royalblue"),
    text=vendas_por_produto["Quantidade Vendida"],
    textposition="auto"
))

# Ajustar layout do gr√°fico
fig.update_layout(
    title="Quantidade Vendida por Produto",
    xaxis_title="Produto",
    yaxis_title="Quantidade Vendida",
    xaxis=dict(tickangle=-45),
    template="plotly_white"
)

# Exibir o gr√°fico interativo
fig.show()

"""## üìä An√°lise de Vendas por Dia da Semana


---

Nesse bloco vemos a quantidade de vendas por dia de semana, ajudando na visualiza√ß√£o da sazonalidade de vendas dentro de uma semana.

---


"""

# Carregar os dados de vendas
df_vendas = pd.read_csv("compras_barba_de_elite.csv")

# Converter a coluna de data para formato datetime
df_vendas["Data e Hora"] = pd.to_datetime(df_vendas["Data e Hora"])

# Criar uma coluna com o nome do dia da semana em portugu√™s
dias_semana_traducao = {
    "Monday": "Segunda-feira",
    "Tuesday": "Ter√ßa-feira",
    "Wednesday": "Quarta-feira",
    "Thursday": "Quinta-feira",
    "Friday": "Sexta-feira",
    "Saturday": "S√°bado",
    "Sunday": "Domingo"
}

df_vendas["Dia da Semana"] = df_vendas["Data e Hora"].dt.day_name().map(dias_semana_traducao)

# Contar vendas por dia da semana
vendas_por_dia_semana = df_vendas.groupby("Dia da Semana").size()

# Reordenar para come√ßar na segunda-feira
ordem_dias = ["Segunda-feira", "Ter√ßa-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "S√°bado", "Domingo"]
vendas_por_dia_semana = vendas_por_dia_semana.reindex(ordem_dias)

# Criar gr√°fico interativo
fig = go.Figure()

fig.add_trace(go.Bar(
    x=vendas_por_dia_semana.index,
    y=vendas_por_dia_semana.values,
    marker=dict(color="royalblue"),
    text=vendas_por_dia_semana.values,
    textposition="auto"
))

# Ajustar layout do gr√°fico
fig.update_layout(
    title="Vendas por Dia da Semana",
    xaxis_title="Dia da Semana",
    yaxis_title="N√∫mero de Vendas",
    template="plotly_white"
)

# Exibir o gr√°fico interativo
fig.show()

"""## üì¶ Rela√ß√£o entre Estoque e Vendas

---

Nesse bloco temos um headmap que nos mostra uma rela√ß√£o de vendas por estoque.

---


"""

# Carregar os dados de vendas e estoque
df_vendas = pd.read_csv("compras_barba_de_elite.csv")
df_estoque = pd.read_csv("estoque_barba_de_elite.csv")

# Calcular a m√©dia de vendas di√°rias por produto
total_dias = df_vendas["Data e Hora"].nunique()
media_vendas_produto = df_vendas.groupby("Produto").size().div(total_dias).reset_index(name="M√©dia de Vendas Di√°rias")

# Mesclar com a base de estoque
estoque_vendas = df_estoque.merge(media_vendas_produto, left_on="Nome do Produto", right_on="Produto", how="left")
estoque_vendas.drop(columns=["Produto"], inplace=True)

# Calcular DOH (Days On Hand) e Estoque Ideal
estoque_vendas["Days On Hand (DOH)"] = estoque_vendas["Quantidade em Estoque"] / estoque_vendas["M√©dia de Vendas Di√°rias"]
estoque_vendas["Estoque Ideal (30 dias)"] = estoque_vendas["M√©dia de Vendas Di√°rias"] * 30

# Criar gr√°fico interativo de dispers√£o entre estoque e vendas
fig = px.scatter(
    estoque_vendas,
    x="Quantidade em Estoque",
    y="M√©dia de Vendas Di√°rias",
    text="Nome do Produto",
    title="Rela√ß√£o entre Estoque e Vendas",
    labels={"Quantidade em Estoque": "Quantidade em Estoque", "M√©dia de Vendas Di√°rias": "M√©dia de Vendas Di√°rias"},
    color="Days On Hand (DOH)",  # Cor indicando o DOH
    size="M√©dia de Vendas Di√°rias",
    hover_name="Nome do Produto",
)

# Ajustes no layout
fig.update_traces(marker=dict(opacity=0.7, line=dict(width=1, color="DarkSlateGrey")))
fig.update_layout(template="plotly_white")

# Exibir gr√°fico interativo
fig.show()

"""## üìå C√°lculo de Days On Hand (DOH) e Estoque Ideal

---

Aqui vemos uma an√°lise de DOH (Days on hand) que nos mostra quantos dias levar√° para vendermos todo nosso estoque atual, baseado nas vendas anteriores.

---


"""

# Carregar os dados de vendas
df_vendas = pd.read_csv("compras_barba_de_elite.csv")

# Converter a coluna de data para formato datetime
df_vendas["Data e Hora"] = pd.to_datetime(df_vendas["Data e Hora"])
# Creating 'Data' column here to ensure it exists
df_vendas["Data"] = df_vendas["Data e Hora"].dt.date

# Contar o n√∫mero de dias distintos na base de vendas
total_dias = df_vendas["Data"].nunique()

# Calcular a m√©dia de vendas di√°rias corretamente
media_vendas_produto = df_vendas.groupby('Produto').size().div(total_dias).reset_index(name='M√©dia de Vendas Di√°rias')

# Mesclar com a base de estoque
estoque_vendas = df_estoque.merge(media_vendas_produto, left_on='Nome do Produto', right_on='Produto', how='left')
estoque_vendas.drop(columns=['Produto'], inplace=True)

# Calcular DOH corretamente
estoque_vendas['Days On Hand (DOH)'] = estoque_vendas['Quantidade em Estoque'] / estoque_vendas['M√©dia de Vendas Di√°rias']

# Calcular estoque ideal para 30 dias de cobertura
estoque_vendas['Estoque Ideal (30 dias)'] = estoque_vendas['M√©dia de Vendas Di√°rias'] * 30

# Exibir tabela corrigida
estoque_vendas.head()

"""## üìä An√°lise de Ticket M√©dio Cliente e Compra

---

Esse bloco nos d√° a visualiza√ß√£o do TM por cliente e por compra.

---


"""

# Ticket m√©dio por cliente
ticket_medio_cliente = df_vendas.groupby("ID Usu√°rio")["Valor"].sum().mean()

# Ticket m√©dio por compra
ticket_medio_compra = df_vendas.groupby("ID Compra")["Valor"].sum().mean()

print(f"üí∞ Ticket M√©dio por Cliente: R$ {ticket_medio_cliente:.2f}")
print(f"üõí Ticket M√©dio por Compra: R$ {ticket_medio_compra:.2f}")

"""## üìä Itens Mais Comprados Juntos

---

Esse bloco nos mostra ideias de kits que podem ser criados, por esses s√£o os itens mais comprados juntos em uma √∫nica compra.

---


"""

# Import the necessary module
from itertools import combinations
from collections import Counter # Import Counter from collections

# Criar um dicion√°rio para armazenar os produtos comprados em cada ID de compra
compras_dict = df_vendas.groupby("ID Compra")["Produto"].apply(list)

# Gerar todas as combina√ß√µes poss√≠veis de produtos
todas_combinacoes = []
for produtos in compras_dict:
    # Now 'combinations' is defined and can be used
    todas_combinacoes.extend(combinations(produtos, 2))

# Contar as combina√ß√µes mais comuns
comb_count = Counter(todas_combinacoes)
mais_comprados_juntos = comb_count.most_common(5)  # Top 5

# Exibir os produtos mais comprados juntos
print("üîó Produtos mais comprados juntos:")
for (prod1, prod2), qtd in mais_comprados_juntos:
    print(f"{prod1} + {prod2} ‚Üí {qtd} vezes")

"""## üìä Dia de Maior Venda

---

Esse bloco nos d√° a visualiza√ß√£o do dia com maior venda, possibilidando a visibilidade de alguma a√ß√£o que deu certo ou nos levando a pensar no motivo dessa m√°xima de vendas.

---


"""

# Garantir que a coluna Data e Hora seja datetime
df_vendas["Data e Hora"] = pd.to_datetime(df_vendas["Data e Hora"])

# Criar uma coluna apenas com a data (sem hor√°rio)
df_vendas["Data"] = df_vendas["Data e Hora"].dt.date

# Encontrar o dia com maior n√∫mero de vendas
pico_vendas = df_vendas["Data"].value_counts().idxmax()

print(f"üìÖ Dia com maior n√∫mero de vendas: {pico_vendas}")

"""## üîÑ Taxa de clientes recorrentes

---

Esse bloco nos d√° a taxa de recorr√™ncia de clientes , mostrando quantos % dos clientes voltam a comprar nossos produtos.

---


"""

clientes_com_varias_compras = df_vendas["ID Usu√°rio"].value_counts()
taxa_recorrencia = (clientes_com_varias_compras > 1).mean() * 100
print(f"üîÑ Taxa de clientes recorrentes: {taxa_recorrencia:.2f}%")

"""## üìä Distribui√ß√£o da Faixa de Pre√ßo

---

Nesse bloco vemos um histograma com a distribui√ß√£o de feixa de pre√ßo mais recorrentes entre as compras.

---


"""

# Garantir que a coluna de data seja datetime
df_vendas["Data e Hora"] = pd.to_datetime(df_vendas["Data e Hora"])

# Agrupar as compras pelo ID da Compra para calcular o valor total gasto por compra
compras_agrupadas = df_vendas.groupby("ID Compra")["Valor"].sum().reset_index()

# Definir faixas de pre√ßo para segmenta√ß√£o
bins = [0, 50, 100, 200, 500, 1000]
labels = ["At√© R$50", "R$50-100", "R$100-200", "R$200-500", "Acima de R$500"]

# Classificar cada compra em uma faixa de pre√ßo
compras_agrupadas["Faixa de Pre√ßo"] = pd.cut(compras_agrupadas["Valor"], bins=bins, labels=labels)

# Contar quantidade de compras por faixa de pre√ßo (considerando compras √∫nicas)
faixa_preco = compras_agrupadas["Faixa de Pre√ßo"].value_counts().sort_index()

# Criar gr√°fico interativo
fig = px.bar(
    x=faixa_preco.index,
    y=faixa_preco.values,
    text=faixa_preco.values,
    labels={"x": "Faixa de Pre√ßo", "y": "Quantidade de Compras"},
    title="Distribui√ß√£o de Compras por Faixa de Pre√ßo",
    color=faixa_preco.values,
    color_continuous_scale="Blues"
)

# Ajustar layout
fig.update_traces(textposition="auto")
fig.update_layout(
    xaxis_title="Faixa de Pre√ßo",
    yaxis_title="Quantidade de Compras",
    template="plotly_white"
)

# Exibir gr√°fico interativo
fig.show()